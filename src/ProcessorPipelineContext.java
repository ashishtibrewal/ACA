/**
 * Class that stores intermediate stage values that is used to communicate between different stages of the pipeline (i.e. This class
 * is shared by all the stages in the pipeline). This class can be thought of as the control unit (CU) of the processor, since it control 
 * how all the values that are updated based on the output from all the other units. It can also be thought of as storing/containing the
 * "state of the cpu", both current and next states since if holds references to the architectural registers and memory. This class
 * also contains a method to shift the contents of the pipeline along for the next cycle - note that this method is called by the shift() method
 * contained in the processorPipeline object, which is called by its execute() method after having completed running all the stages in the pipeline for
 * the current cycle.
 * Note: Variables prefixed with "current" refers to the values for the current cycle (i.e. the present running cycle, T = t). These are read by each stage in
 * the pipleline in the current cycle, whereas variables prefixed with "next" refers to the values for the next cycle (i.e. T = t + 1). There are set by each 
 * stage in the pipeline in the current cycle FOR THE NEXT CYCLE.   
 */
import pipeline.*;

import java.util.*;

/**
 * This class is used to store the shared state of the pipeline. This class is accessed by all the pipeline stages to read and update values when required.
 */
public class ProcessorPipelineContext implements IPipelineContext
{
  private Register cpuRegisters;                          /** Reference to architectural registers */
  private Memory cpuMemory;                               /** Reference to main memory */
  private IStage instructionFetchStage;                   /** Reference to the Instruction Fetch Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private IStage instructionDecodeStage;                  /** Reference to the Instruction Decode Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private IStage instructionIssueStage;                   /** Reference to the Instruction Issue Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private IStage instructionExecuteStage;                 /** Reference to the Instruction Execute Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private IStage instructionWritebackStage;               /** Reference to the Instruction Writeback Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private BranchPredictor branchPredictor;                /** Reference to the processor's branch prediction unit */
  private boolean branchTaken;                            /** Variable stating if the BU, i.e. Branch Unit evaluated that a branch needs to be taken. Based on this variable the pipeline would need to be flushed */
  private boolean branchTakenOld;                         /** Variable to store the previous value of branchTaken. ONLY USED FOR PRINTING/DEBUGGING PURPOSE. */
  private int branchTarget;                               /** Variable holding the branch target address */
  private int nextIR;                                     /** Updated IR value generated by the IF stage */
  private int currentIR;                                  /** Previous IR value read by the ID stage */
  private Instruction nextInstruction;                    /** Reference to the next instruction */   // TODO this should actually be a list of instructions when going superscalar becase in one cycle the instruction fetch unit would fetch multiple executions 
  private Instruction currentInstruction;                 /** Reference to the current instruction */   // TODO this should actually be a list of instructions when going superscalar becase in one cycle the instruction fetch unit would fetch multiple executions
  private Queue<Instruction> nextInstructionQueue;        /** Reference to the next instruction queue - Similar to a reservation station */
  private Queue<Instruction> currentInstructionQueue;     /** Reference to the current instruction queue - Similar to a reservation station */
  private int nextMemoryFetchLoc;                         /** Updated memory fetch location value set by the IF stage */
  private int currentMemoryFetchLoc;                      /** Previous memory fetch location value read by the ID stage */
  private boolean stallPipeline;                          /** Boolean variable stating if the pipeline should be stalled */   //TODO Check if individual variables to stall each stage would be a better way to handle this
  private boolean nextInstructionBranchPredictionResult;  /** Branch predictor results for the next instruction */
  private boolean currentInstructionBranchPredictionResult; /** Branch predictor results for the current instruction */
  private boolean correctBranchPrediction;                /** Boolean variable that stores whether or not the branch prediction was correct. If it was incorrect this variable is set to false and the pipeline needs to be flushed, else the simulator can carry on as usual */
  private Instruction nextInstructionWriteBack;           /** Reference to the next writeback instruction */   // TODO this should actually be a list of instructions when going superscalar becase in one cycle the instruction fetch unit would fetch multiple executions 
  private Instruction currentInstructionWriteBack;        /** Reference to the current writeback instruction */   // TODO this should actually be a list of instructions when going superscalar becase in one cycle the instruction fetch unit would fetch multiple executions

  public ProcessorPipelineContext(Register cpuRegisters, Memory cpuMemory, IStage instructionFetchStage, IStage instructionDecodeStage, IStage instructionIssueStage, IStage instructionExecuteStage, IStage instructionWritebackStage, BranchPredictor branchPredictor)
  {
    this.cpuRegisters = cpuRegisters;
    this.cpuMemory = cpuMemory;
    this.instructionFetchStage = instructionFetchStage;
    this.instructionDecodeStage = instructionDecodeStage;
    this.instructionIssueStage = instructionIssueStage;
    this.instructionExecuteStage = instructionExecuteStage;
    this.instructionWritebackStage = instructionWritebackStage;
    this.branchPredictor = branchPredictor;
    this.currentIR = GlobalConstants.DEFAULT_INSTRUCTION;         // Default IR value, declared as 0, hence, signifies a NOP operation
    this.currentInstruction = new Instruction(GlobalConstants.DEFAULT_INSTRUCTION_TYPE,
                                              GlobalConstants.DEFAULT_INSTRUCTION_MNEMONIC,
                                              ExecutionUnit.ALU,
                                              GlobalConstants.DEFAULT_INSTRUCTION_OPCODE, 
                                              GlobalConstants.DEFAULT_MEM_FETCH_LOC,
                                              GlobalConstants.DEFAULT_INSTRUCTION,
                                              Isa.InstructionType.RRR.NUMBER_OF_CYCLES,
                                              GlobalConstants.DEFAULT_BRANCH_PREDICTION,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_IMM_VALUE);         // Instantiate current instruction obeject as a NOP operation otherwise the Instruction Issue (II) stage throws a null pointer exception in the because it gets an Instruction object reference that hasn't been instantiated (i.e. this reference doesn't point to any object). Useful when the later stages of the pipeline are empty in the first few cycles of the simulation.
    this.currentInstructionQueue = new LinkedList<Instruction>();             // Instantiate current instruction queue object to avoid null pointer exceptions to be generated by the the II stage (Useful only for the first clock cycle).
    this.currentInstructionQueue.add(new Instruction(GlobalConstants.DEFAULT_INSTRUCTION_TYPE,
                                                     GlobalConstants.DEFAULT_INSTRUCTION_MNEMONIC,
                                                     ExecutionUnit.ALU,
                                                     GlobalConstants.DEFAULT_INSTRUCTION_OPCODE, 
                                                     GlobalConstants.DEFAULT_MEM_FETCH_LOC,
                                                     GlobalConstants.DEFAULT_INSTRUCTION,
                                                     Isa.InstructionType.RRR.NUMBER_OF_CYCLES,
                                                     GlobalConstants.DEFAULT_BRANCH_PREDICTION,
                                                     Isa.DEFAULT_REG_VALUE,
                                                     Isa.DEFAULT_REG_VALUE,
                                                     Isa.DEFAULT_REG_VALUE,
                                                     Isa.DEFAULT_IMM_VALUE)); // Insert a NOP operation to the current instruction queue read by the IE stage. This prevents a null pointer exception in the first execution cycle of the IE stage.
    this.nextInstructionQueue = new LinkedList<Instruction>();                // Instantiate the next instruction queue object to avoid null pointer exceptions to be generated by the II stage (Useful only for the first clock cycle).
    this.currentInstructionWriteBack = new Instruction(GlobalConstants.DEFAULT_INSTRUCTION_TYPE,
                                                       GlobalConstants.DEFAULT_INSTRUCTION_MNEMONIC,
                                                       ExecutionUnit.ALU,
                                                       GlobalConstants.DEFAULT_INSTRUCTION_OPCODE, 
                                                       GlobalConstants.DEFAULT_MEM_FETCH_LOC,
                                                       GlobalConstants.DEFAULT_INSTRUCTION,
                                                       Isa.InstructionType.RRR.NUMBER_OF_CYCLES,
                                                       GlobalConstants.DEFAULT_BRANCH_PREDICTION,
                                                       Isa.DEFAULT_REG_VALUE,
                                                       Isa.DEFAULT_REG_VALUE,
                                                       Isa.DEFAULT_REG_VALUE,
                                                       Isa.DEFAULT_IMM_VALUE);  // Instantiate current instruction obeject as a NOP operation otherwise the Instruction Writeback (WB) stage throws a null pointer exception in the because it gets an Instruction object reference that hasn't been instantiated (i.e. this reference doesn't point to any object). Useful when the later stages of the pipeline are empty in the first few cycles of the simulation.
    this.currentMemoryFetchLoc = GlobalConstants.DEFAULT_MEM_FETCH_LOC;                                  // Default memory fetch location
    this.currentInstructionBranchPredictionResult = GlobalConstants.DEFAULT_BRANCH_PREDICTION;           // Default branch prediction value 
    this.stallPipeline = false;
    this.correctBranchPrediction = GlobalConstants.CORRECT_BRANCH_PREDICTION_RESULT;      // By default this value is set to true, if this was set to false, the pipeline would be flushed every cycle which is not what we want
  }
  
  /**
   * Method to shift the contents of each stage along the pipleine
   */
  public void shiftPipeline()
  {
    currentInstruction = nextInstruction;
    //currentInstruction = new Instruction(nextInstruction);      // Use the copy constructor to "clone" the next instruction object to the current instruction object
    currentIR = nextIR;                                         // Clone the value contained in the instruction register
    currentInstructionQueue = nextInstructionQueue;             // Copy the reference of the nextInstructionQueue to the currentInstructionQueue
    currentInstructionWriteBack = nextInstructionWriteBack;
    //currentInstructionWriteBack = new Instruction(nextInstructionWriteBack);     // Use the copy constructor to "clone" the next writeback instruction object to the current writeback instruction object
    currentMemoryFetchLoc = nextMemoryFetchLoc;                 // Copy the memory fetch location value
    currentInstructionBranchPredictionResult = nextInstructionBranchPredictionResult; // Copy the branch prediction result value
    //branchTaken = false;                                        // Revert the value of the branchTaken variable back to false for it to be used in the next cycle - This is currently being done in the IE stage
  }

  /**
   * Method to flush the pipeline registers (i.e. the current and next value registers that connect the different stages in the pipeline)
   * ONLY FLUSH STAGES BEFORE THE EXECUTE STAGE.     
   */
  public void flush()
  {
    this.currentIR = GlobalConstants.DEFAULT_INSTRUCTION;
    this.currentInstruction = new Instruction(GlobalConstants.DEFAULT_INSTRUCTION_TYPE,
                                              GlobalConstants.DEFAULT_INSTRUCTION_MNEMONIC,
                                              ExecutionUnit.ALU,
                                              GlobalConstants.DEFAULT_INSTRUCTION_OPCODE, 
                                              GlobalConstants.DEFAULT_MEM_FETCH_LOC,
                                              GlobalConstants.DEFAULT_INSTRUCTION,
                                              Isa.InstructionType.RRR.NUMBER_OF_CYCLES,
                                              GlobalConstants.DEFAULT_BRANCH_PREDICTION,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_IMM_VALUE);         // Instantiate current instruction obeject as a NOP operation otherwise the Instruction Issue (II) stage throws a null pointer exception in the because it gets an Instruction object reference that hasn't been instantiated (i.e. this reference doesn't point to any object). Useful when the later stages of the pipeline are empty in the first few cycles of the simulation.
    ((LinkedList) this.nextInstructionQueue).clear();                         // Empty the next instruction queue read by the IE stage
    this.currentInstructionQueue = new LinkedList<Instruction>();             // Instantiate current instruction queue object to avoid null pointer exceptions to be generated by the the II stage (Useful only for the first clock cycle).
    this.currentInstructionQueue.add(new Instruction(GlobalConstants.DEFAULT_INSTRUCTION_TYPE,
                                                     GlobalConstants.DEFAULT_INSTRUCTION_MNEMONIC,
                                                     ExecutionUnit.ALU,
                                                     GlobalConstants.DEFAULT_INSTRUCTION_OPCODE, 
                                                     GlobalConstants.DEFAULT_MEM_FETCH_LOC,
                                                     GlobalConstants.DEFAULT_INSTRUCTION,
                                                     Isa.InstructionType.RRR.NUMBER_OF_CYCLES,
                                                     GlobalConstants.DEFAULT_BRANCH_PREDICTION,
                                                     Isa.DEFAULT_REG_VALUE,
                                                     Isa.DEFAULT_REG_VALUE,
                                                     Isa.DEFAULT_REG_VALUE,
                                                     Isa.DEFAULT_IMM_VALUE)); // Insert a NOP operation to the current instruction queue read by the IE stage. This prevents a null pointer exception in the first execution cycle of the IE stage.
    this.currentMemoryFetchLoc = GlobalConstants.DEFAULT_MEM_FETCH_LOC;                                  // Default memory fetch location
    this.currentInstructionBranchPredictionResult = GlobalConstants.DEFAULT_BRANCH_PREDICTION;           // Default branch prediction value 
  }

  /**
   * Method to obtain (a reference) to the cpu registers object
   * @return Reference to the cpu registers object
   */
  public Register getCpuRegisters()
  {
    return cpuRegisters;
  }

  /**
   * Method to obtain (a reference) to the cpu memory object
   * @return Reference to the cpu memory object
   */
  public Memory getCpuMemory()
  {
    return cpuMemory;
  }

  /**
   * Method to set the next value to to be stored in the instruction register (IR).
   * Used (i.e. value set by) IF stage.
   * @param _nextIR Next IR value
   */
  public void setNextIR(int _nextIR)
  {
    nextIR = _nextIR;
    cpuRegisters.writeIR(_nextIR);        // Write the most recent instruction value read by the IF stage to the actual instruction register (IR) contained in the cpuRegister object
  }

  /**
   * Method to obtain the current value stored in the instruction register (IR).
   * Used (i.e. value read by) ID stage.
   * @return Current value store in the IR
   */
  public int getCurrentIR()
  {
    return currentIR;
  }

  /**
   * Method to set the next instruction.
   * Used (i.e. value set by) ID stage.
   * @param _nextInstruction Latest decoded instruction
   */
  public void setNextInstruction(Instruction _nextInstruction)
  {
    nextInstruction = _nextInstruction;
  }

  /**
   * Method to obtain (a reference) to the current instruction object.
   * Used (i.e. value read by) II stage.
   * @return Reference to the current instruction object
   */
  public Instruction getCurrentInstruction()
  {
    return currentInstruction;
  }

  /**
   * Method to set/add the next instruction to the instruction queue
   * Used (i.e value set by) II stage
   * @param nextInstruction Instruction to be added to the instruction queue
   */
  public void setNextInstructionToInstructionQueue(Instruction nextInstruction)
  {     
    nextInstructionQueue.add(nextInstruction);
  }

  /**
   * Method to obtain the current instruction from the instruction queue
   * Used (i.e. value read by) IE stage
   * @return Current instruction (from the instruction queue) to be executed
   */
  public Instruction getCurrentInstructionFromInstructionQueue()
  {
    if (currentInstructionQueue.size() != 0)        // Check made to see if the instruction queue is not empty
    {
      return currentInstructionQueue.remove();      // Remove the head element from the instruction queue for it to be executed by the IE stage
    }
    else            // If the instruction queue is empty throw a NullPointerException exception with a custom message 
    {
      throw new NullPointerException("Fatal error! Instruction queue is empty, hence, there is no instruction in the insruction queue to be read and executed by the IE stage for the current cycle!");
    }
  }

  /**
   * Method to set the boolean value stating if a branch needs to be taken, hence, requiring the pipeline to be flushed. This method is usually only called by the Branch Unit (BU), i.e. the Bu class.
   * @param _branchTaken Boolean value stating if a branch is taken.
   */
  public void setBranchTaken(boolean _branchTaken)
  {
    branchTaken = _branchTaken;
  }

  /**
   * Method to obtain the boolean value stating if a branch needs to be taken, hence, requiring the pipeline to be flushed.
   * @return Boolean value stating if a branch is taken
   */
  public boolean getBranchTaken()
  {
    return branchTaken;
  }

  /**
   * Method to set the branch target address, only used by the BU if a branch needs to taken
   * @param  _branchTarget Branch target address
   */
  public void setBranchTarget(int _branchTarget)
  {
    branchTarget = _branchTarget;               // Update the branch target value stored in the context
    cpuRegisters.writePC(_branchTarget);        // Write the branch target value to the branch target field in the cpuRegisters object
  }

  /**
   * Method to obtain the value of the branch target address. Used when updating the PC value to the branch target address
   * @return Branch target address
   */
  public int getBranchTarget()
  {
    return branchTarget;
  }

  /**
   * Method to store/set the old value of branchTaken into branchTakenOld. THIS IS ONLY USED FOR PRINTING/DEBUGGING PURPOSES.
   * This needs to be done since the actual branchTaken variable gets updated back to false after being used by the instruction
   * execute (IE) stage and before the processor pipeline status has been printed for the correct cycle. If this is not done
   * then the printed values would be incorrect.
   * @param setDefault Boolean variable stating if the default value should be used
   */
  public void setBranchTakenOld(boolean setDefault)
  {
    if (setDefault == true)
    {
      branchTakenOld = false;
    }
    else
    {
      branchTakenOld = branchTaken;
    }
  }

  /**
   * Method to obtain old value of branchTaken. THIS IS ONLY USED FOR PRINTING/DEBUGGING PURPOSES.
   * @return Old value of the branchTaken variable
   */
  public boolean getBranchTakenOld()
  {
    return branchTakenOld;
  }

  /**
   * Method to set the memory fetch location for the latest fetched instruction. This value is set by the IF stage 
   * @param _nextMemoryFetchLoc Memory fetch location of the instruction (Current PC value)
   */
  public void setNextMemoryFetchLoc(int _nextMemoryFetchLoc)
  {
    nextMemoryFetchLoc = _nextMemoryFetchLoc;
  }

  /**
   * Method to obtain the memory fetch location for the latest decoded instruction (i.e. instruction fetched in the 
   * previous cycle by the IF stage). This value is used by the ID stage.
   * @return Memory location of the instruction (i.e. Memory location/address from where the instruction was fetched)
   */
  public int getCurrentMemoryFetchLoc()
  {
    return currentMemoryFetchLoc;
  }

  /**
   * Method to obtain a reference to the processor's branch prediction (BP) unit. This method is used by the IF stage
   * @return Reference to the processor's branch prediction (BP) unit
   */
  public BranchPredictor getBranchPredictor()
  {
    return branchPredictor;
  }

  /**
   * Method to set the branch predictor's result for the next instruction. Only useful for (conditional) branch instructions.
   * Used (i.e. value set by) by the IF stage.
   * @param _nextInstructionBranchPredictionResult Branch predictor's result for this instruction (true = BP predicted branch taken, false = BP predicted branch not taken)
   */
  public void setNextInstructionBranchPredictionResult(boolean _nextInstructionBranchPredictionResult)
  {
    nextInstructionBranchPredictionResult = _nextInstructionBranchPredictionResult;
  }

  /**
   * Method to obtain the branch predictor's result for the current instruction. Only useful for (conditional) branch instructions.
   * Used (i.e. value read by) by the ID stage.
   * @return Branch predictor's result for this instruction (true = BP predicted branch taken, false = BP predicted branch not taken)
   */
  public boolean getCurrentInstructionBranchPredictionResult()
  {
    return currentInstructionBranchPredictionResult;
  }

  /** 
   * Method to set whether or not the branch predictor's prediction was correct or not.
   * Set by the branch unit (BU) in the IE stage
   * @param _correctBranchPrediction Branch predictor's prediction check result (true = BP predicted correctly, false = BP mispredicted)
   */
  public void setCorrectBranchPrediction(boolean _correctBranchPrediction)
  {
    correctBranchPrediction = _correctBranchPrediction;
  }

  /**
   * Method to obtain a value that states whether or not a branch was predicted correctly 
   * @return Branch predictor's prediction check result (true = BP predicted correctly, false = BP mispredicted)
   */
  public boolean getCorrectBranchPrediction()
  {
    return correctBranchPrediction;
  }

  /**
   * Method to obtain the instruction to be used by the instruction writeback (WB) stage
   * @return Instruction to be used to write back values to registers for the current cycle
   */
  public Instruction getCurrentInstructionWriteBack()
  {
    return currentInstructionWriteBack;
  }

  /**
   * Method to set the next instruction to be used by the instruction writeback (WB) stage
   * @param _nextInstructionWriteBack Lastest executed instruction
   */
  public void setNextInstructionWriteBack(Instruction _nextInstructionWriteBack)
  {
    nextInstructionWriteBack = _nextInstructionWriteBack;
  }

  /**
   * Method to obtain a reference to the Instruction Fetch (IF) Stage object, instructionFetchStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the IF Stage obejct
   */
  public IStage getIF_Stage()
  {
    return instructionFetchStage;
  }

  /**
   * Method to obtain a reference to the Instruction Decode (ID) Stage object, instructionDecodeStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the ID Stage obejct
   */
  public IStage getID_Stage()
  {
    return instructionDecodeStage;
  }

  /**
   * Method to obtain a reference to the Instruction Issue (II) Stage object, instructionIssueStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the II Stage obejct
   */
  public IStage getII_Stage()
  {
    return instructionIssueStage;
  }

  /**
   * Method to obtain a reference to the Instruction Execute (IE) Stage object, instructionExecuteStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the IE Stage obejct
   */
  public IStage getIE_Stage()
  {
    return instructionExecuteStage;
  }

  /**
   * Method to obtain a reference to the Instruction Writeback (WB) Stage object, instructionWritebackStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the WB Stage obejct
   */
  public IStage getWB_Stage()
  {
    return instructionWritebackStage;
  }
}