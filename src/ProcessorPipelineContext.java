/**
 * Class that stores intermediate stage values that is used to communicate between different stages of the pipeline (i.e. This class
 * is shared by all the stages in the pipeline). This class can be thought of as the control unit (CU) of the processor, since it control 
 * how all the values that are updated based on the output from all the other units. It can also be thought of as storing/containing the
 * "state of the cpu", both current and next states since if holds references to the architectural registers and memory. This class
 * also contains a method to shift the contents of the pipeline along for the next cycle - note that this method is called by the shift() method
 * contained in the processorPipeline object, which is called by its execute() method after having completed running all the stages in the pipeline for
 * the current cycle.
 */
import pipeline.*;

import java.util.*;

/**
 * This class is used to store the shared state of the pipeline. This class is accessed by all the pipeline stages to read and update values when required.
 */
public class ProcessorPipelineContext implements IPipelineContext
{
  private Register cpuRegisters;                 /** Reference to architectural registers */
  private Memory cpuMemory;                      /** Reference to main memory */
  private IStage instructionFetchStage;          /** Reference to the Instruction Fetch Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private IStage instructionDecodeStage;         /** Reference to the Instruction Decode Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private IStage instructionIssueStage;          /** Reference to the Instruction Issue Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private IStage instructionExecuteStage;        /** Reference to the Instruction Execute Stage of the pipeline. Useful if something is required from this stage by other stages. */
  private int nextIR;                            /** Updated IR value generated by the IF stage */
  private int currentIR;                         /** Previous IR value read by the ID stage */
  private Instruction nextInstruction;           /** Reference to the next instruction */   // TODO this should actually be a list of instructions when going superscalar becase in one cycle the instruction fetch unit would fetch multiple executions 
  private Instruction currentInstruction;        /** Reference to the current instruction */   // TODO this should actually be a list of instructions when going superscalar becase in one cycle the instruction fetch unit would fetch multiple executions
  private boolean branchTaken;                   /** Variable stating if the BU, i.e. Branch Unit evaluated that a branch needs to be taken. Based on this variable the pipeline would need to be flushed */
  private int branchTarget;                      /** Variable holding the branch target address */

  public ProcessorPipelineContext(Register cpuRegisters, Memory cpuMemory, IStage instructionFetchStage, IStage instructionDecodeStage, IStage instructionIssueStage, IStage instructionExecuteStage)
  {
    this.cpuRegisters = cpuRegisters;
    this.cpuMemory = cpuMemory;
    this.instructionFetchStage = instructionFetchStage;
    this.instructionDecodeStage = instructionDecodeStage;
    this.instructionIssueStage = instructionIssueStage;
    this.instructionExecuteStage = instructionExecuteStage;
    this.currentIR = 0;         // Default IR value, declared as 0, hence, signifies a NOP operation
    this.currentInstruction = new Instruction("RRR",
                                              "NOP",
                                              ExecutionUnit.ALU,
                                              0, 
                                              0,
                                              0,
                                              Isa.InstructionType.RRR.NUMBER_OF_CYCLES,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_REG_VALUE,
                                              Isa.DEFAULT_IMM_VALUE);        // Instantiate current instruction obeject as a NOP operation otherwise the Instruction Issue (II) stage throws a null pointer exception in the because it gets an Instruction object reference that hasn't been instantiated (i.e. this reference doesn't point to any object). Useful when the later stages of the pipeline are empty in the first few cycles of the simulation.
  }
  // TODO Add functions and fields to handle outputs from other stages of the pipeline. (I.e. instruction fetch output, instruction decode output etc)
  // TODO WOULD NEED TO HAVE TWO COPIES OF CERTAIN FIELDS, ONE TO STORE THE VALUES FOR THE CURRENT CYCLE AND THE NEXT TO STORE VALUES FOR THE NEXT CYCLE
  
  /**
   * Method to obtain (a reference) to the cpu registers object
   * @return Reference to the cpu registers object
   */
  public Register getCpuRegisters()
  {
    return cpuRegisters;
  }

  /**
   * Method to obtain (a reference) to the cpu memory object
   * @return Reference to the cpu memory object
   */
  public Memory getCpuMemory()
  {
    return cpuMemory;
  }

  /**
   * Method to set the next value to to be stored in the instruction register (IR).
   * Used (i.e. value set by) IF stage.
   * @param _nextIR [description]
   */
  public void setNextIR(int _nextIR)
  {
    nextIR = _nextIR;
    cpuRegisters.writeIR(_nextIR);        // Write the most recent instruction value read by the IF stage to the actual instruction register (IR) contained in the cpuRegister object
  }

  /**
   * Method to obtain the current value stored in the instruction register (IR).
   * Used (i.e. value read by) ID stage.
   * @return [description]
   */
  public int getCurrentIR()
  {
    return currentIR;
  }

  /**
   * Method to set the next instruction.
   * Used (i.e. value set by) ID stage.
   * @param _currentInstruction Latest decoded instruction
   */
  public void setNextInstruction(Instruction _nextInstruction)
  {
    nextInstruction = _nextInstruction;
  }

  /**
   * Method to obtain (a reference) to the current instruction object.
   * Used (i.e. value read by) II stage.
   * @return Reference to the current instruction object
   */
  public Instruction getCurrentInstruction()
  {
    return currentInstruction;
  }

  /**
   * Method to obtain (a reference) to the instruction queue object (Note that the instruction queue object is contained in the Instruction Issue Stage object)
   * @return Reference to the instruction queue object
   */
  public Queue<Instruction> getInstructionQueue()
  {
    return ((InstructionIssueStage) instructionIssueStage).getInstructionQueue();
  }

  /**
   * Method to set the boolean value stating if a branch needs to be taken, hence, requiring the pipeline to be flushed. This method is usually only called by the Branch Unit (BU), i.e. the Bu class.
   * @param _branchTaken Boolean value stating if a branch is taken.
   */
  public void setBranchTaken(boolean _branchTaken)
  {
    branchTaken = _branchTaken;
  }

  /**
   * Method to obtain the boolean value stating if a branch needs to be taken, hence, requiring the pipeline to be flushed.
   * @return Boolean value stating if a branch is taken
   */
  public boolean getBranchTaken()
  {
    return branchTaken;
  }

  /**
   * Method to set the branch target address, only used by the BU if a branch needs to taken
   * @param  _branchTarget Branch target address
   */
  public void setBranchTarget(int _branchTarget)
  {
    branchTarget = _branchTarget;               // Update the branch target value stored in the context
    cpuRegisters.writePC(_branchTarget);        // Write the branch target value to the branch target field in the cpuRegisters object
  }

  /**
   * Method to obtain the value of the branch target address. Used when updating the PC value to the branch target address
   * @return Branch target address
   */
  public int getBranchTarget()
  {
    return branchTarget;
  }

  /**
   * Method to shift the contents of each stage along the pipleine
   */
  public void shiftPipeline()
  {
    currentInstruction = new Instruction(nextInstruction);      // Use the copy constructor to "clone" the next instruction object to the current instruction object
    currentIR = nextIR;     // Clone the value contained in the instruction register.
  }

  /**
   * Method to obtain a reference to the Instruction Fetch (IF) Stage object, instructionFetchStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the IF Stage obejct
   */
  public IStage getIF_Stage()
  {
    return instructionFetchStage;
  }

  /**
   * Method to obtain a reference to the Instruction Decode (ID) Stage object, instructionDecodeStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the ID Stage obejct
   */
  public IStage getID_Stage()
  {
    return instructionDecodeStage;
  }

  /**
   * Method to obtain a reference to the Instruction Issue (II) Stage object, instructionIssueStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the II Stage obejct
   */
  public IStage getII_Stage()
  {
    return instructionIssueStage;
  }

  /**
   * Method to obtain a reference to the Instruction Execute (IE) Stage object, instructionExecuteStage.
   * USED ONLY FOR PRINTING AND DEBUGGING.
   * @return Reference to the IE Stage obejct
   */
  public IStage getIE_Stage()
  {
    return instructionExecuteStage;
  }
}